#!/usr/bin/env python2.7

"""
This script parses and aggregates Swift function body compile times from an
Xcode build log. It can either print errors/warnings that Xcode will pick up
from a Run Script build step, or tell you your worst N blocks.

Tested exclusively with Swift 2.2 and Xcode 7.3.1.

To use it, you need an Xcode build log generated by a build with a special
setting: `OTHER_SWIFT_FLAGS="-Xfrontend -debug-time-function-bodies"`.

You'll probably also want to clean all relevant targets first.

You can create a target for use by a continuous integration server to report
long compile times as errors by creating an 'aggregate' target and adding a
Run Script phase like this:

    # xcodebuild subprocesses to rm, which prints errors we
    # don't care about at all
    exec 3>&2
    exec 2> /dev/null

    # save log to /tmp/
    LOG_PATH=`mktemp /tmp/build.log.XXXXXX` || exit 1

    # call xcodebuild...from within Xcode. INCEPTION
    xcodebuild \
        -workspace MyWorkspace.xcworkspace
        -scheme "My scheme" \
        -sdk iphonesimulator9.3 \  # or whatever
        OTHER_SWIFT_FLAGS="-Xfrontend -debug-time-function-bodies" \
        > $LOG_PATH

    # now get our stderr back so we can print errors
    exec 2>&3

    # report all function body compile times >500ms as an error
    /path/to/parse_swift_compile_times.py --max-time=500 $LOG_PATH

    # remove temp file
    rm $LOG_PATH
"""

from __future__ import print_function

import argparse
import logging
import re
import sys

from collections import namedtuple


TIMING_LINE_RE = re.compile(r'(?P<ms>\d+\.\d+)ms\s+(?P<path>[^:]+):(?P<line>\d+):(?P<col>\d+)\s+(?P<name>.+)')
Location = namedtuple('Location', ['path', 'line', 'col', 'name'])


logging.basicConfig(level=logging.INFO)
log = logging.getLogger('parse_build_times')


class Measurement(object):
    def __init__(self):
        self.blocks = {}
        super(Measurement, self).__init__()

    def record(self, ms, path, line, col, name):
        location = Location(path, line, col, name)
        self.blocks.setdefault(location, 0)
        self.blocks[location] += float(ms)

    def print_worst_blocks(self, n=10):
        print('Worst blocks:')
        sorted_pairs = sorted(self.blocks.items(), key=lambda pair: -pair[1])
        for (location, time) in sorted_pairs[:n]:
            print('  {}ms - {}:{}:{}'.format(time, location.path, location.line, location.name))

    def print_error_for_times_greater_than(self, max_time, severity='error'):
        had_error = False
        for location, ms in self.blocks.iteritems():
            if ms > max_time:
                print("{}:{}:{}: {}: {}ms compile time".format(
                    location.path, location.line, location.col, severity, ms))
                had_error = True
        return had_error


def main():
    parser = argparse.ArgumentParser(__doc__)
    parser.add_argument('infile', type=argparse.FileType('r'), default=sys.stdin)
    parser.add_argument(
        '-n', default=None, type=int,
        help="If provided, print the worst N blocks")
    parser.add_argument(
        '-t', '--max-time', default=None, type=int,
        help="If provided, print a line that will cause Xcode to add an error pointing to the relevant location")
    parser.add_argument(
        '--just-warn',
        help='(used with --max-time) Signal a warning instead of an error to Xcode')
    args = parser.parse_args()

    measurement = Measurement()
    for line in args.infile:
        m = TIMING_LINE_RE.match(line)
        if m:
            measurement.record(**m.groupdict())

    if args.n is not None:
        measurement.print_worst_blocks(args.n)

    if args.max_time is not None:
        has_error = measurement.print_error_for_times_greater_than(
            args.max_time, "warning" if args.just_warn else "error")
        if has_error:
            return 1

    return 0


if __name__ == '__main__':
    sys.exit(main() or 0)
